clear all; clc;
addpath(genpath('/home/morolong/Documents/Msc/symbiotic_backscatter_ris_assisted_noma'));
rng('shuffle');

% Initialize parameters
para = para_init();
[BS_array, RIS_array] = generate_arrays(para);
[H, g, f] = generate_channel(para, BS_array, RIS_array);

% Constants
max_feasible = 20;
max_iter = 15;
outer_iter = para.outer_iter;
MC_MAX = para.MC_MAX;
K = para.K;
N = para.N;
M = para.M;

% Preallocate results
obj_history_all = zeros(outer_iter, MC_MAX);
rng_seeds = randi(1e6, MC_MAX);

% Create parallel pool if not exists
% if isempty(gcp('nocreate'))
%     num_workers = min(feature('numcores'), MC_MAX);
%     pool = parpool('local', num_workers);
%     fprintf('Using %d workers for parallel processing\n', pool.NumWorkers);
% else
%     pool = gcp;
%     fprintf('Existing pool with %d workers found\n', pool.NumWorkers);
% end

% Main parallel loop
tic;
for mc = 1:MC_MAX
    try
        fprintf('Monte Carlo Iteration %d\n', mc);
        
        % Set random seed for reproducibility
        stream = RandStream('mt19937ar', 'Seed', rng_seeds(mc));
        RandStream.setGlobalStream(stream);
        
        % Initialize local variables for this MC run
        u = exp(1i * pi * (2 * rand(N, 1)));
        Theta = diag(u);
        Theta_1 = diag(u);
        
        % Generate channels for this MC run
        [H_local, g_local, f_local] = generate_channel(para, BS_array, RIS_array);
        
        % Precompute channel components as local variables
        g_1_all = cell(1, K);
        g_2_all = cell(1, K);
        g_b_all = cell(1, K);
        f1_all = cell(1, K);
        f2_all = cell(1, K);
        
        for i = 1:K
            g_1_all{i} = g_local(:, i, 1) * 100;
            g_2_all{i} = g_local(:, i, 2) * 100;
            g_b_all{i} = g_local(:, i, 3) * 100;
            f1_all{i} = f_local(i, 1);
            f2_all{i} = f_local(i, 2);
        end
        G_all_matrix = H_local * 100;
        
        % MRT beamforming initialization
        H_n = cell(1, K);
        for i = 1:K
            H_n{i} = g_1_all{i}' * Theta_1 * H_local * para.scal;
        end
        w_k = mrt_beamforming(para, H_n{1}, H_n{2});
        
        % % Feasible Taylor points - Active BF
        % A_n_prev = ones(K, 1); 
        % B_n_prev = ones(K, 1) * 1e-0;
        % A_f_prev = ones(K, 1) * 1e-0; 
        % B_f_prev = ones(K, 1);
        % A_c_prev_n = ones(K, 1); 
        % B_c_prev_n = ones(K, 1) * 1e-0;
        % 
        % [~, A_n_opt, B_n_opt, A_f_opt, B_f_opt, A_c_n_opt, B_c_n_opt, ~, ~, converged] = ...
        %     find_feasible_solution(para, Theta, G_all_matrix, g_1_all, g_2_all, ...
        %     g_b_all, f1_all, f2_all, A_n_prev, B_n_prev, A_f_prev, B_f_prev, ...
        %     A_c_prev_n, B_c_prev_n, max_feasible, mc);
        % 
        % if ~converged
        %     continue;
        % end
        
        % % % Update Taylor points
        % A_n_prev = A_n_opt; B_n_prev = B_n_opt; 
        % A_f_prev = A_f_opt; B_f_prev = B_f_opt; 
        % A_c_prev_n = A_c_n_opt; B_c_prev_n = B_c_n_opt;

        % Feasible Taylor points - Passive BF
        A_n_prev_p = ones(K, 1); 
        B_n_prev_p = ones(K, 1) * 1e-0;
        A_f_prev_p = ones(K, 1) * 1e-0; 
        B_f_prev_p = ones(K, 1);
        A_c_prev_n_p = ones(K, 1); 
        B_c_prev_n_p = ones(K, 1) * 1e-0;

        [V_opt_feasible, A_n_opt_p, B_n_opt_p, A_f_opt_p, B_f_opt_p, ...
         A_c_n_opt_p, B_c_n_opt_p, ~, ~] = feasible_passive(para, w_k, G_all_matrix, ...
         g_1_all, g_2_all, g_b_all, f1_all, f2_all, A_n_prev_p, B_n_prev_p, ...
         A_f_prev_p, B_f_prev_p, A_c_prev_n_p, B_c_prev_n_p);

        % Update Taylor points
        A_n_prev_p = A_n_opt_p; B_n_prev_p = B_n_opt_p; 
        A_f_prev_p = A_f_opt_p; B_f_prev_p = B_f_opt_p; 
        A_c_prev_n_p = A_c_n_opt_p; B_c_prev_n_p = B_c_n_opt_p;
        
        % Outer iteration loop
         obj_history_mc = zeros(outer_iter, 1);
        
        for tau_1 = 1:outer_iter
            % % Active BF optimization
            % [W_opt, A_n_opt, B_n_opt, A_f_opt, B_f_opt, A_c_n_opt, B_c_n_op, ...
            %  obj_history_, ~, converged, ~] = active_Bf_opt(para, Theta, G_all_matrix, ...
            %  g_1_all, g_2_all, g_b_all, f1_all, f2_all, A_n_prev, B_n_prev, ...
            %  A_f_prev, B_f_prev, A_c_prev_n, B_c_prev_n, max_iter, tau_1);
            % 
            % 
            % % Update Taylor points and extract beamforming vectors
            % A_n_prev = A_n_opt; B_n_prev = B_n_opt; 
            % A_f_prev = A_f_opt; B_f_prev = B_f_opt; 
            % A_c_prev_n = A_c_n_opt; B_c_prev_n = B_c_n_opt;
            % 
            % for k = 1:K
            %     [W_max, max_eigenvalue_w] = max_eigVect(W_opt(:, :, k));
            %     w_k(:, k) = sqrt(max_eigenvalue_w) * W_max;
            % end
            
            % Passive BF optimization
            [V_opt, A_n_opt_p, B_n_opt_p, A_f_opt_p, B_f_opt_p, A_c_n_opt_p, ...
             B_c_n_opt_p, ~, ~, converged] = passive_BF_opt(para, w_k, G_all_matrix, ...
             g_1_all, g_2_all, g_b_all, f1_all, f2_all, A_n_prev_p, B_n_prev_p, ...
             A_f_prev_p, B_f_prev_p, A_c_prev_n_p, B_c_prev_n_p, max_iter, tau_1);


            % Update Taylor points
            A_n_prev_p = A_n_opt_p; B_n_prev_p = B_n_opt_p; 
            A_f_prev_p = A_f_opt_p; B_f_prev_p = B_f_opt_p; 
            A_c_prev_n_p = A_c_n_opt_p; B_c_prev_n_p = B_c_n_opt_p;

            % Extract optimal phase shifts
            [U, S] = eig((V_opt + V_opt') / 2);
            [lambda1, idx] = max(real(diag(S)));
            v = sqrt(lambda1) * U(:, idx);

            % Test candidate solutions
            cand = {exp(1j * angle(v)), exp(-1j * angle(v)), ...
                    conj(exp(1j * angle(v))), conj(exp(-1j * angle(v)))};

            bestWSR = -inf;
            for t = 1:4
                theta_test = diag(cand{t});
                WSR = calculate_WSR(para, w_k, G_all_matrix, g_1_all, g_2_all, ...
                                    g_b_all, f1_all, f2_all, para.alpha_k_n, ...
                                    para.alpha_k_f, theta_test);
                if WSR > bestWSR
                    bestWSR = WSR;
                    Theta = theta_test;
                end
            end

            % Store results
            obj_history_mc(tau_1) = bestWSR;
         end
        
        % Store results for this MC run
        WSR = calculate_WSR(para, w_k, G_all_matrix, g_1_all, g_2_all, ...
                                    g_b_all, f1_all, f2_all, para.alpha_k_n, ...
                                    para.alpha_k_f, theta_test);
        obj_history_mc(tau_1) = WSR;
        obj_history_all(:, mc) = obj_history_mc;
        
    catch ME
        fprintf('Error in MC iteration %d: %s\n', mc, ME.message);
        obj_history_all(:, mc) = NaN;
    end
end

% Cleanup parallel pool
delete(gcp('nocreate'));

% Process results
valid_runs = ~all(isnan(obj_history_all), 1);
obj_history_valid = obj_history_all(:, valid_runs);
avg_obj = mean(obj_history_valid, 2, 'omitnan');
std_obj = std(obj_history_valid, 0, 2, 'omitnan');

disp(avg_obj);


% % Example: plot relax_parameter over iterations
% figure;
 plot(1:max_iter, avg_obj, '-o', 'LineWidth', 1.5);
 xlabel('Iteration');
 ylabel('WSR');
 title('Convergence');
 grid on;

% % Example: plot objective history
% figure;
% plot(1:length(obj_history), obj_history, '-s', 'LineWidth', 1.5);
% xlabel('Iteration');
% ylabel('Objective Value');
% title('Objective History vs Iteration');
% grid on;
toc